#!/usr/bin/env node

/**
 * termcoin
 * Copyright (c) 2013, Christopher Jeffrey
 * https://github.com/chjj/termcoin
 */

// bitcoind -server -daemon -rpcuser=bitcoinrpc -rpcpassword=foobar -rpcport=8332 -rpcallowip=127.0.0.1
// termcoin http://bitcoinrpc:foobar@localhost:8332/
// https://github.com/bitcoin/bitcoin/blob/master/src/rpcserver.cpp
// https://github.com/bitcoin/bitcoin/blob/master/src/rpcrawtransaction.cpp
// https://github.com/bitcoin/bitcoin/blob/master/src/rpcwallet.cpp
// http://blockchain.info/api/json_rpc_api

/**
 * Modules
 */

var fs = require('fs')
  , url = require('url')
  , util = require('util')
  , path = require('path')
  , cp = require('child_process')
  , http = require('http')
  , StringDecoder = require('string_decoder').StringDecoder
  , qs = require('querystring');

var blessed = require('blessed')
  , mock = require('../lib/mock');

var opt = parseArg(process.argv.slice())
  , config = readConf()
  , platform = getPlatform(opt)
  , now = Date.now()
  , decryptTime = 0
  , platform
  , client;

function getPlatform(opt) {
  var name = opt.currency || 'bitcoin';
  var dir = opt.datadir || process.env.HOME + '/.' + name;
  return {
    name: name,
    daemon: name + 'd',
    config: dir + '/' + name + '.conf',
    wallet: dir + '/wallet.dat',
    log: dir + '/debug.log',
    pid: dir + '/' + name + 'd.pid'
  };
}

function readConf() {
  var data;

  try {
    data = fs.readFileSync(platform.config, 'ascii');
  } catch (e) {
    return {};
  }

  data = data.trim().split(/(\r?\n)+/);

  return data.reduce(function(out, line) {
    var parts = line.trim().split(/\s*=\s*/)
      , key = parts[0]
      , val = parts[1];

    out[key] = val;

    return out;
  }, {});
}

function getStats(callback) {
  return getTotalBalance(function(err, balances) {
    if (err) return callback(err);
    return getAccounts(function(err, accounts) {
      if (err) return callback(err);
      return getTransactions(function(err, transactions) {
        if (err) return callback(err);
        return getAddresses(accounts, function(err, addresses) {
          if (err) return callback(err);
          return getInfo(function(err, info) {
            if (err) return callback(err);
            return isEncrypted(function(err, encrypted) {
              if (err) return callback(err);
              return callback(null, {
                balances: balances,
                accounts: accounts,
                transactions: transactions,
                addresses: addresses,
                info: info,
                encrypted: encrypted
              });
            });
          });
        });
      });
    });
  });
}

// Ridiculous workaround:
function getAddresses(accounts, callback) {
  if (opt.remote) return callback(null, []);

  if (!callback) {
    callback = accounts;
    accounts = null;
  }

  var wallet
    , results = []
    , ma = []
    , m;

  try {
    wallet = fs.readFileSync(platform.wallet, 'utf8');
  } catch (e) {
    return callback(null, results);
  }

  // Bitcoin addresses are 27-35 bytes in length.
  // https://bitcointalk.org/index.php?topic=1026.0
  do {
    if (m = /^[a-zA-Z1-9]{27}/g.exec(wallet)) ma.push(m[0]);
    if (m = /^[a-zA-Z1-9]{28}/g.exec(wallet)) ma.push(m[0]);
    if (m = /^[a-zA-Z1-9]{29}/g.exec(wallet)) ma.push(m[0]);
    if (m = /^[a-zA-Z1-9]{30}/g.exec(wallet)) ma.push(m[0]);
    if (m = /^[a-zA-Z1-9]{31}/g.exec(wallet)) ma.push(m[0]);
    if (m = /^[a-zA-Z1-9]{32}/g.exec(wallet)) ma.push(m[0]);
    if (m = /^[a-zA-Z1-9]{33}/g.exec(wallet)) ma.push(m[0]);
    if (m = /^[a-zA-Z1-9]{34}/g.exec(wallet)) ma.push(m[0]);
    if (m = /^[a-zA-Z1-9]{35}/g.exec(wallet)) ma.push(m[0]);
  } while (wallet = wallet.substring(1));

  if (!ma.length) {
    return callback(null, results);
  }

  return forEach(ma, function(address, next) {
    return client.call('getaccount', [address], function(err, name) {
      if (err) return next();
      results.push({
        name: name,
        address: address
      });
      return next();
    });
  }, function() {
    if (accounts) {
      // Exclude the user's addresses.
      var add = Object.keys(accounts).map(function(key) {
        return accounts[key].address;
      });
      results = results.filter(function(item) {
        return add.indexOf(item.address) === -1;
      });
    }
    return callback(null, results);
  });
}

function forEach(obj, iter, done) {
  var pending = obj.length;
  function next() {
    --pending || done();
  }
  obj.forEach(function(item, i) {
    iter(item, next, i);
  });
}

function getAccounts(callback) {
  var results = {};
  return client.call('listaccounts', function(err, accounts) {
    if (err) return callback(err);
    return forEach(Object.keys(accounts), function(name, next) {
      // return client.call('getaccountaddress', [name], function(err, address) {
      return client.call('getaddressesbyaccount', [name], function(err, address) {
        if (err) return next();
        address.forEach(function(address) {
          results[address] = {
            name: name,
            address: address,
            balance: accounts[name]
          };
        });
        return next();
      });
    }, function() {
      return callback(null, results);
    });
  });
}

function getProgress(callback) {
  return client.call('getblockhash', [0], function(err, hash) {
    if (err) return callback(err);
    return client.call('getblock', [hash], function(err, genesis) {
      if (err) return callback(err);
      return client.call('getconnectioncount', function(err, connections) {
        if (err) return callback(err);
        return client.call('getblockcount', function(err, count) {
          if (err) return callback(err);
          return client.call('getblockhash', [count], function(err, hash) {
            if (err) return callback(err);
            return client.call('getblock', [hash], function(err, current) {
              if (err) return callback(err);

              var beginning = genesis.time
                , end = Date.now() / 1000 | 0
                , left = end - current.time
                , perc = ((current.time - beginning) / (end - beginning)) * 100 | 0;

              return callback(null, {
                blocks: count,
                connections: connections,
                genesisBlock: genesis,
                currentBlock: current,
                hoursBehind: left / 60 / 60 | 0,
                daysBehind: left / 60 / 60 / 24 | 0,
                percent: perc
              });
            });
          });
        });
      });
    });
  });
}

function getInfo(callback) {
  return client.call('getinfo', callback);
}

function getTransactions(callback) {
  if (opt.mock) {
    return callback(null, tsort(mock.transactions, true));
  }
  return client.call('listtransactions', ['*', 1000], function(err, transactions) {
    if (err) return callback(err);
    return callback(null, tsort(transactions, true));
  });
}

function getTotalBalance(callback) {
  return client.call('getbalance', ['*', 6], function(err, balance) {
    if (err) return callback(err);
    return client.call('getbalance', ['*', 0], function(err, unconfirmed) {
      if (err) return callback(err);
      unconfirmed -= balance;
      return callback(null, {
        balance: balance,
        unconfirmed: unconfirmed
      });
    });
  });
}

function signMessage(address, message, callback) {
  return client.call('signmessage', [address, message], callback);
}

function verifyMessage(address, sig, message, callback) {
  return client.call('verifymessage', [address, sig, message], callback);
}

function createAddress(name, callback) {
  return client.call('getnewaddress', [name], callback);
}

function listReceivedByAddress(address, callback) {
  if (opt.mock) return callback(null, received);
  return client.call('listreceivedbyaddress', [address, sig, message], callback);
}

function backupWallet(path, callback) {
  return client.call('backupwallet', [path], callback);
}

function encryptWallet(passphrase, callback) {
  return client.call('encryptwallet', [passphrase], callback);
}

function decryptWallet(passphrase, timeout, callback) {
  return client.call('walletpassphrase', [passphrase, timeout], function(err) {
    if (err) {
      if (~err.message.indexOf('Wallet is already unlocked')) {
        return callback();
      }
      return callback(err);
    }
    return callback();
  });
}

function changePassphrase(opassphrase, npassphrase, callback) {
  return client.call('walletpassphrasechange', [opassphrase, npassphrase], callback);
}

function forgetKey(callback) {
  return client.call('walletlock', [], callback);
}

function isEncrypted(callback) {
  return client.call('walletpassphrase', [], function(err) {
    if (err) {
      if (err.code === -15 && ~err.message.indexOf('unencrypted wallet')) {
        return callback(null, false);
      }
      if (~err.message.indexOf('walletpassphrase <passphrase> <timeout>')) {
        return callback(null, true);
      }
      return callback(err);
    }
    return callback(null, true);
  });
}

function send(address, amount, callback) {
  return client.call('sendtoaddress', [address, amount], callback);
}

function sendFrom(from, address, amount, callback) {
  return client.call('sendfrom', [from, address, amount], callback);
}

function move(from, to, amount, callback) {
  return client.call('move', [from, to, amount], callback);
}

function startServer(callback) {
  if (opt.remote) return callback();

  try {
    fs.statSync(platform.pid);
    if (!startServer.started) {
      startServer.started = true;
    }
    return callback();
  } catch (e) {
    ;
  }

  if (!startServer.started) {
    startServer.started = true;
    console.log('Starting new server...');
  }

  var cmd = [
    platform.daemon,
    '-server',
    '-daemon',
    '-rpcuser=' + config.rpcuser,
    '-rpcpassword=' + config.rpcpassword,
    '-rpcport=' + config.rpcport,
    '-rpcallowip=127.0.0.1'
  ].join(' ');

  return cp.exec('(setsid ' + cmd + ' > /dev/null 2>& 1 &)', function(err) {
    if (err) return callback(err);
    return setTimeout(function() {
      return callback();
    }, 12 * 1000);
  });
}

function start(stats, callback) {
  var screen = blessed.screen({
    autoPadding: true,
    fastCSR: true
  });

  var target;

  var wrapper = blessed.box({
    parent: screen,
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  });

  var bar = blessed.listbar({
    parent: wrapper,
    top: 0,
    left: 0,
    right: 0,
    height: 1,
    keys: true,
    mouse: true,
    autoCommandKeys: true,
    style: {
      bg: 'black',
      item: {
        bg: 'blue'
      },
      selected: {
        bg: 'lightblue'
      },
      prefix: {
        fg: 'green'
      }
    }
  });

  var sep = blessed.line({
    parent: wrapper,
    top: 1,
    left: 0,
    right: 0,
    orientation: 'horizontal'
  });

  var tabs = {};

  ['overview',
   'send',
   'receive',
   'transactions',
   'addresses',
   'misc',
   'logs',
   'debug'].forEach(function(name) {
    var tab = tabs[name] = blessed.box({
      top: 2,
      left: 0,
      right: 0,
      bottom: 0,
      scrollable: true,
      keys: true,
      vi: true,
      alwaysScroll: true,
      scrollbar: {
        ch: ' '
      },
      style: {
        scrollbar: {
          inverse: true
        }
      }
    });

    bar.addItem({
      text: name,
      callback: function() {
        if (target) target.detach();
        wrapper.append(tab);
        tab.focus();
        target = tab;
        screen.render();
      }
    });
  });

  bar.commands[0].callback();

  /**
   * Overview
   */

  tabs.overview._.wallet = blessed.text({
    parent: tabs.overview,
    top: 0,
    left: 3,
    height: 'shrink',
    width: '40%',
    label: ' {blue-fg}Wallet{/blue-fg} ',
    tags: true,
    border: {
      type: 'line'
    },
    content: 'No balance.',
    tags: true
  });

  tabs.overview._.transactions = blessed.text({
    parent: tabs.overview,
    top: 0,
    right: 3,
    height: 'shrink',
    width: '40%',
    label: ' {blue-fg}Transactions{/blue-fg} ',
    tags: true,
    border: {
      type: 'line'
    },
    content: 'No transactions.',
    tags: true
  });

  tabs.overview._.data = blessed.box({
    parent: tabs.overview,
    bottom: 0,
    left: 3,
    // XXX Fix in blessed: - probably has something to do with bottom: 0
    // height: 'shrink',
    height: 6,
    width: '40%',
    label: ' {blue-fg}Data{/blue-fg} ',
    tags: true,
    border: 'line',
    content: 'Loading... ',
    style: {
      fg: 'lightblack',
      bar: {
        bg: 'blue'
      }
    }
  });

  tabs.overview._.bar = blessed.progressbar({
    parent: tabs.overview._.data,
    top: 3,
    left: 0,
    right: 0,
    height: 'shrink',
    orientation: 'horizontal',
    filled: 0,
    ch: '|',
    tags: true,
    //content: 'Syncing... ',
    style: {
      fg: 'lightblack',
      bar: {
        bg: 'blue'
      }
    }
  });

  (function self() {
    return getProgress(function(err, data) {
      if (data) {
        tabs.overview._.data.setContent(
          'Connections: ' + data.connections + '\n'
          + 'Blocks: ' + data.blocks + ' (' + data.percent + '%)\n'
          + (data.daysBehind >= 1
          ? data.daysBehind + ' Days Behind'
          : data.hoursBehind + ' Hours Behind'));
        //tabs.overview._.bar.content = data.blocks + ' (' + data.percent + '%)';
        tabs.overview._.bar.setProgress(data.percent);
        screen.render();
      }
      setTimeout(self, 2000);
    });
  })();

  // tabs.overview._.backup = blessed.button({
  //   parent: tabs.overview,
  //   bottom: 0,
  //   right: 3,
  //   height: 'shrink',
  //   width: 'shrink',
  //   content: 'Backup Wallet',
  //   tags: true,
  //   border: 'line',
  //   mouse: true,
  //   keys: true,
  //   style: {
  //     fg: 'default',
  //     bg: 'blue',
  //     hover: {
  //       bg: 'lightblack'
  //     },
  //     border: {
  //       bg: 'blue'
  //     }
  //   }
  // });

  function backup() {
    return screen._.prompt.type('Save to:', process.env.HOME, function(err, value) {
      if (err) {
        screen.render();
        return screen._.msg.error(err.message);
      }
      if (value == null) {
        screen.render();
        return;
      }
      var stat;
      try {
        stat = fs.statSync(value);
      } catch (e) {
        ;
      }
      if (stat && stat.isDirectory()) {
        value = value.replace(/\/+$/, '') + '/wallet.dat.bak';
      }
      return backupWallet(value, function(err) {
        if (err) return screen._.msg.error(err.messsage);
        screen._.msg.display('Wallet successfully backed up.');
        screen.render();
      });
    });
  }

  // tabs.overview._.backup.on('press', function() {
  //   backup();
  // });

  /**
   * Send
   */

  tabs.send.on('focus', function() {
    tabs.send._.form.focus();
  });

  tabs.send._.form = blessed.form({
    parent: tabs.send,
    top: 0,
    left: 1,
    right: 1,
    //height: 9,
    // Fixed in blessed:
    height: 'shrink',
    keys: true,
    mouse: true,
    label: ' {blue-fg}Send{/blue-fg} ',
    border: 'line',
    tags: true,
    autoNext: true
  });

  tabs.send._.ttext = blessed.text({
    parent: tabs.send._.form,
    top: 0,
    left: 0,
    height: 1,
    content: 'Pay {underline}T{/underline}o:',
    tags: true
  });

  tabs.send._.address = blessed.textbox({
    parent: tabs.send._.form,
    name: 'address',
    inputOnFocus: true,
    top: 0,
    left: 9,
    right: 1,
    height: 1,
    style: {
      bg: 'black',
      focus: {
        bg: 'blue'
      },
      hover: {
        bg: 'blue'
      }
    }
  });

  tabs.send._.ltext = blessed.text({
    parent: tabs.send._.form,
    top: 2,
    left: 0,
    height: 1,
    content: ' {underline}L{/underline}abel:',
    tags: true
  });

  tabs.send._.label = blessed.textbox({
    parent: tabs.send._.form,
    name: 'label',
    inputOnFocus: true,
    top: 2,
    left: 9,
    right: 1,
    height: 1,
    style: {
      bg: 'black',
      focus: {
        bg: 'blue'
      },
      hover: {
        bg: 'blue'
      }
    }
  });

  tabs.send._.mtext = blessed.text({
    parent: tabs.send._.form,
    top: 4,
    left: 0,
    height: 1,
    content: 'A{underline}m{/underline}ount:',
    tags: true
  });

  tabs.send._.amount = blessed.textbox({
    parent: tabs.send._.form,
    name: 'amount',
    inputOnFocus: true,
    top: 4,
    left: 9,
    right: 1,
    height: 1,
    style: {
      bg: 'black',
      focus: {
        bg: 'blue'
      },
      hover: {
        bg: 'blue'
      }
    }
  });

  tabs.send._.ftext = blessed.text({
    parent: tabs.send._.form,
    top: 6,
    left: 0,
    height: 1,
    content: ' {underline}F{/underline}rom:',
    tags: true,
    hidden: true
  });

  tabs.send._.from = blessed.textbox({
    parent: tabs.send._.form,
    name: 'from',
    inputOnFocus: true,
    top: 6,
    left: 9,
    right: 1,
    height: 1,
    style: {
      bg: 'black',
      focus: {
        bg: 'blue'
      },
      hover: {
        bg: 'blue'
      }
    },
    hidden: true
  });

  tabs.send._.submit = blessed.button({
    parent: tabs.send._.form,
    name: 'submit',
    top: 6,
    right: 1,
    height: 1,
    width: 'shrink',
    content: ' Send ',
    style: {
      bg: 'black',
      focus: {
        bg: 'blue'
      },
      hover: {
        bg: 'blue'
      }
    }
  });

  tabs.send._.note = blessed.text({
    parent: tabs.send._.form,
    top: 8,
    left: 0,
    height: 'shrink',
    right: 10,
    content: 'Press {blue-fg}Ctrl-E{/blue-fg} to select an address.',
    tags: true
  });

  tabs.send._.submit.on('press', function() {
    tabs.send._.form.submit();
  });

  tabs.send._.form.on('submit', function(data) {
    if (tabs.send._.from.visible) {
      tabs.send._.ftext.hide();
      tabs.send._.from.hide();
      tabs.send._.submit.rtop = 6;
      tabs.send._.note.rtop = 8;
    }

    var alias = stats.addresses.reduce(function(out, item) {
      out[item.name] = item;
      return out;
    }, {});

    // Own addresses: for 'move' calls.
    alias = Object.keys(stats.accounts).reduce(function(out, key) {
      out[stats.accounts[key].name] = stats.accounts[key];
      return out;
    }, alias);

    if (data.address && alias[data.address]) {
      data.address = alias[data.address].address;
    }

    if (data.address && stats.accounts[data.address]) {
      data.move = true;
    }

    return checkEncrypt(function(err) {
      if (err) return screen._.msg.error(err.message);

      var checkLabel = function(callback) {
        if (!data.label) return callback();
        return client.call('setaccount', [data.address, data.label], callback);
      };

      var sendTo = function(callback) {
        if (data.from) {
          if (data.move) {
            return move(data.from, data.address, +data.amount);
          }
          return sendFrom(data.from, data.address, +data.amount, callback);
        }
        return send(data.address, +data.amount, callback);
      };

      return sendTo(function(err, result) {
        if (err) return screen._.msg.error(err.message);
        if (!result || !Object.keys(result).length) {
          return screen._.msg.error('Transaction not completed.');
        }
        return checkLabel(function(err) {
          screen._.msg.display(
            'Transaction completed successfully: '
            + result.txid + '.');
        });
      });
    });
  });

  function pickAddress(callback) {
    var addresses = stats.addresses.map(function(item) {
      return item.name || item.address;
    });

    // XXX Own
    var accounts = Object.keys(stats.accounts).map(function(key) {
      var item = stats.accounts[key];
      return item.name || item.address;
    });
    addresses = addresses.concat(accounts);

    screen._.picker.setItems(addresses);

    return screen._.picker.pick(callback);
  }

  function _pick() {
    return pickAddress(function(err, value) {
      if (err) return screen.render();
      tabs.send._.address.setValue(value);
      tabs.send._.address.focus();
      screen.render();
    });
  }

  tabs.send._.form.key(['C-e', 'C-t', 'e', 't'], function() {
    tabs.send._.form._selected = tabs.send._.address;
    //tabs.send._.address.focus();
    _pick();
  });
  tabs.send._.form.key(['L', 'l'], function() {
    tabs.send._.label.focus();
  });
  tabs.send._.form.key('m', function() {
    tabs.send._.amount.focus();
  });
  tabs.send._.address.key(['C-e','C-t'], _pick);

  /**
   * Receive
   */

  tabs.receive.on('focus', function() {
    tabs.receive._.list.focus();
  });

  tabs.receive._.list = blessed.list({
    parent: tabs.receive,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    style: {
      scrollbar: {
        inverse: true
      },
      selected: {
        bg: 'blue'
      },
      item: {
        hover: {
          bg: 'blue'
        }
      }
    },
    scrollbar: {
      ch: ' '
    }
  });

  tabs.receive._.list.key('d', function() {
    deleteAddress();
  });

  function deleteAddress() {
    var list = tabs.receive._.list
      , el = list.items[list.selected];

    var parts = el.getText().trim().split(/\s+/)
      , label = parts[0]
      , address = parts[1];

    screen._.question.ask('Are you sure you want to delete this?', function(err, value) {
      if (err) return screen._.msg.error(err.message);
      if (!value) return screen.render();

      return screen._.msg.error('Not supported.');

      // Does not delete.
      return client.call('setaccount', [address], function(err) {
        if (err) return screen._.msg.error(err.message);
        text = 'Deleted address: {blue-fg}' + address + '{/blue-fg}';
        screen._.msg.display(text);
        screen.render();
        refresh();
      });
    });
  }

  tabs.receive._.list.on('select', function(el, index) {
    var parts = el.getText().trim().split(/\s+/)
      , label = parts[0]
      , address = parts[1]
      , text;

    if (label === 'new') {
      text = 'Label for new address:';
      return screen._.prompt.type(text, '', function(err, value) {
        if (err) return screen._.msg.error(err.message);
        value = value || '';
        return createAddress(value, function(err, address) {
          if (err) return screen._.msg.error(err.message);
          text = 'Created address: {blue-fg}' + address + '{/blue-fg}';
          screen._.msg.display(text);
          screen.render();
          refresh();
        });
      });
    }

    screen._.picker.setItems([
      'Copy Address',
      'Copy Label',
      'Rename',
      'Delete',
      //'-',
      'Send From',
      'Show QR Code',
      'Save QR Code PNG',
      'Sign Message'
    ]);

    return screen._.picker.pick(function(err, option) {
      if (err) return screen._.msg.error(err.message);

      if (option === 'Copy Address') {
        return copy(address);
      }

      if (option === 'Copy Label') {
        return copy(label);
      }

      if (option === 'Rename') {
        text = 'Label for {blue-fg}' + address + '{/blue-fg}:';
        return screen._.prompt.type(text, '', function(err, newLabel) {
          if (err) return screen._.msg.error(err.message);

          return screen._.msg.error('Not supported.');

          newLabel = newLabel || '';

          // Does not associate address with new account name, just creates a
          // new account with a new address.
          return client.call('setaccount', [address, newLabel], function(err) {
            if (err) return screen._.msg.error(err.message);
            text = 'Edited label: {blue-fg}'
              + label + '->' + (newLabel || '[none]') + '{/blue-fg}';
            screen._.msg.display(text);
            screen.render();
            refresh();
          });
        });
      }

      if (option === 'Delete') {
        return deleteAddress();
      }

      if (option === 'Send From') {
        tabs.send._.submit.rtop = 8;
        tabs.send._.note.rtop = 10;
        tabs.send._.ftext.show();
        tabs.send._.from.show();
        // XXX Fix this in blessed - shouldn't have to do this:
        screen.emit('keypress', '2', { name: '2' });
        tabs.send._.from.setValue(address);
        tabs.send._.form.focusFirst();
        screen.render();
        return;
      }

      if (option === 'Show QR Code') {
        var code = 'bitcoin:' + address + '?label=' + label;
        // TODO: Add prompt for an optional message:
        //+ '&message=' + message;
        return cp.execFile('qrencode', ['-t', 'ANSI256', code], function(err, stdout, stderr) {
          if (err) {
            return screen._.msg.error('qrencode not found. Please install it.');
          }
          screen._.qrbox._.show(stdout.trim());
        });
      }

      if (option === 'Save QR Code PNG') {
        return screen._.prompt.type('Save to:', process.env.HOME + '/', function(err, file) {
          if (err) return screen._.msg.error(err.message);
          var code = 'bitcoin:' + address + '?label=' + label;
          // TODO: Add prompt for an optional message:
          //+ '&message=' + message;
          return cp.execFile('qrencode', ['-t', 'PNG', '-o', file, code], function(err, stdout, stderr) {
            if (err) {
              return screen._.msg.error('qrencode not found. Please install it.');
            }
            return screen._.msg.display('Successfully saved file.');
          });
        });
      }

      if (option === 'Sign Message') {
        // XXX Fix this in blessed - shouldn't have to do this:
        screen.emit('keypress', '6', { name: '2' });
        tabs.misc._.list.select(3);
        tabs.misc._.list.emit('keypress', '\r', { name: 'enter' });
        var i = screen._.picker.ritems.indexOf(address);
        if (!~i) i = screen._.picker.ritems.indexOf(label);
        if (!~i) return;
        screen._.picker.select(i);
        screen._.picker.emit('keypress', '\r', { name: 'enter' });
        screen.render();
        return;
      }
    });
  });

  /**
   * Transactions
   */

  tabs.transactions.on('focus', function() {
    tabs.transactions._.list.focus();
  });

  tabs.transactions._.list = blessed.list({
    parent: tabs.transactions,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    style: {
      scrollbar: {
        inverse: true
      },
      selected: {
        bg: 'blue'
      },
      item: {
        hover: {
          bg: 'blue'
        }
      }
    },
    scrollbar: {
      ch: ' '
    }
  });

  tabs.transactions._.msg = blessed.message({
    parent: tabs.transactions,

    // Fixed in blessed.
    top: 'center',
    left: 'center',
    height: 'shrink',
    width: 'shrink',

    //top: 2,
    //left: 4,
    //right: 4,
    //bottom: 2,

    scrollable: true,
    alwaysScroll: true,
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    hidden: true,
    border: 'line',
    scrollbar: {
      ch: ' '
    },
    style: {
      scrollbar: {
        bg: 'blue'
      }
    }
  });

  tabs.transactions._.list.on('select', function(el, index) {
    var tx = tsort(stats.transactions)[index];

    screen._.picker.setItems([
      'Copy Address',
      'Copy Label',
      'Copy Amount',
      'Edit Label',
      'Details'
    ]);

    return screen._.picker.pick(function(err, option) {
      if (err) return screen._.msg.error(err.message);

      if (option === 'Copy Address') {
        return copy(tx.address || tx.otheraccount);
      }

      if (option === 'Copy Label') {
        return copy(tx.label);
      }

      if (option === 'Copy Amount') {
        return copy(tx.amount + '');
      }

      if (option === 'Edit Label') {
        return;
      }

      if (option === 'Details') {
        var getTransaction = function(id, callback) {
          if (opt.mock) {
            return callback(null, mock.transaction);
          }
          return client.call('gettransaction', [id], callback);
        };

        return getTransaction(tx.txid, function(err, transaction) {
          if (err) return screen._.msg.error(err.message);
          var text = inspect(transaction);
          tabs.transactions._.msg.display(text, -1);
        });
      }
    });
  });

  /**
   * Addresses
   */

  tabs.addresses.on('focus', function() {
    tabs.addresses._.list.focus();
  });

  tabs.addresses._.list = blessed.list({
    parent: tabs.addresses,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    style: {
      scrollbar: {
        inverse: true
      },
      selected: {
        bg: 'blue'
      },
      item: {
        hover: {
          bg: 'blue'
        }
      }
    },
    scrollbar: {
      ch: ' '
    }
  });

  tabs.addresses._.list.key('d', function() {
    deleteSendAddress();
  });

  function deleteSendAddress() {
    var list = tabs.addresses._.list
      , el = list.items[list.selected];

    var parts = el.getText().trim().split(/\s+/)
      , label = parts[0]
      , address = parts[1];

    screen._.question.ask('Are you sure you want to delete this?', function(err, value) {
      if (err) return screen._.msg.error(err.message);
      if (!value) return screen.render();

      return screen._.msg.error('Not supported.');

      // Does not delete.
      return client.call('setaccount', [address], function(err) {
        if (err) return screen._.msg.error(err.message);
        text = 'Deleted address: {blue-fg}' + address + '{/blue-fg}';
        screen._.msg.display(text);
        screen.render();
        refresh();
      });
    });
  }

  tabs.addresses._.list.on('select', function(el, index) {
    var parts = el.getText().trim().split(/\s+/)
      , label = parts[0]
      , address = parts[1]
      , text;

    if (label === 'new') {
      text = 'Label for new address:';
      return screen._.prompt.type(text, '', function(err, label) {
        if (err) return screen._.msg.error(err.message);
        if (!label) return screen.render();
        text = 'Address:';
        return screen._.prompt.type(text, '', function(err, address) {
          if (err) return screen._.msg.error(err.message);
          if (!address) return screen.render();
          return client.call('setaccount', [address, label], function(err) {
            if (err) return screen._.msg.error(err.message);
            text = 'Created address: {blue-fg}' + label + '{/blue-fg}';
            screen._.msg.display(text);
            screen.render();
            refresh();
          });
        });
      });
    }

    screen._.picker.setItems([
      'Copy Address',
      'Copy Label',
      'Rename',
      'Delete',
      //'-',
      'Send Coins',
      'Show QR Code',
      'Save QR Code PNG',
      'Verify Message'
    ]);

    return screen._.picker.pick(function(err, option) {
      if (err) return screen._.msg.error(err.message);

      if (option === 'Copy Address') {
        return copy(address);
      }

      if (option === 'Copy Label') {
        return copy(label);
      }

      if (option === 'Rename') {
        text = 'Label for {blue-fg}' + address + '{/blue-fg}:';
        return screen._.prompt.type(text, label, function(err, newLabel) {
          if (err) return screen._.msg.error(err.message);
          if (!newLabel) return screen.render();

          return screen._.msg.error('Not supported.');

          // For some reason this *creates* a receivable address by the same
          // account name, but different address.
          return client.call('setaccount', [address, newLabel], function(err) {
            if (err) return screen._.msg.error(err.message);
            text = 'Edited label: {blue-fg}'
              + label + '->' + (newLabel || '[none]') + '{/blue-fg}';
            screen._.msg.display(text);
            screen.render();
            refresh();
          });
        });
      }

      if (option === 'Delete') {
        return deleteSendAddress();
      }

      if (option === 'Send Coins') {
        // XXX Fix this in blessed - shouldn't have to do this:
        screen.emit('keypress', '2', { name: '2' });
        tabs.send._.address.setValue(address);
        tabs.send._.form.focusFirst();
        screen.render();
        return;
      }

      if (option === 'Show QR Code') {
        var code = 'bitcoin:' + address + '?label=' + label;
        // TODO: Add prompt for an optional message:
        //+ '&message=' + message;
        return cp.execFile('qrencode', ['-t', 'ANSI256', code], function(err, stdout, stderr) {
          if (err) {
            return screen._.msg.error('qrencode not found. Please install it.');
          }
          screen._.qrbox._.show(stdout.trim());
        });
      }

      if (option === 'Save QR Code PNG') {
        return screen._.prompt.type('Save to:', process.env.HOME + '/', function(err, file) {
          if (err) return screen._.msg.error(err.message);
          var code = 'bitcoin:' + address + '?label=' + label;
          // TODO: Add prompt for an optional message:
          //+ '&message=' + message;
          return cp.execFile('qrencode', ['-t', 'PNG', '-o', file, code], function(err, stdout, stderr) {
            if (err) {
              return screen._.msg.error('qrencode not found. Please install it.');
            }
            return screen._.msg.display('Successfully saved file.');
          });
        });
      }

      if (option === 'Verify Message') {
        // XXX Fix this in blessed - shouldn't have to do this:
        screen.emit('keypress', '6', { name: '2' });
        tabs.misc._.list.select(2);
        tabs.misc._.list.emit('keypress', '\r', { name: 'enter' });
        screen._.prompt._.input.setValue(address);
        screen._.prompt._.input.emit('keypress', '\r', { name: 'enter' });
        screen.render();
        return;
      }
    });
  });

  /**
   * Misc
   */

  tabs.misc._.list = blessed.list({
    parent: tabs.misc,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    style: {
      scrollbar: {
        inverse: true
      },
      selected: {
        bg: 'blue'
      },
      item: {
        hover: {
          bg: 'blue'
        }
      }
    },
    scrollbar: {
      ch: ' '
    },
    items: [
      'Encrypt Wallet',
      'Backup Wallet',
      'Verify Message Signature',
      'Sign Message',
      'Rescan Block Chain',
      'Set Transaction Fee',
      'Import Private Key',
      'Dump Private Key',
      'Refill Key Pool',
      'Toggle Coin Generation',
      'Get Mining Info'
    ]
  });

  tabs.misc.on('focus', function() {
    tabs.misc._.list.focus();
  });

  process.on('uncaughtException', function(err) {
    if (client.lock) return;
    console.error(err.stack);
    process.exit(1);
  });

  tabs.misc._.list.on('select', function(el, index) {
    var text = el.getText();

    if (text === 'Encrypt Wallet') {
      return isEncrypted(function(err, encrypted) {
        if (err) return screen._.msg.error(err.message);
        if (encrypted) {
          screen._.prompt._.input.censor = true;
          return screen._.prompt.type('Current Passphrase:', '', function(err, opassphrase) {
            screen._.prompt._.input.censor = false;
            if (err) return screen._.msg.error(err.message);
            if (opassphrase == null) return screen.render();
            screen._.prompt._.input.censor = true;
            return screen._.prompt.type('New passphrase:', '', function(err, npassphrase) {
              screen._.prompt._.input.censor = false;
              if (err) return screen._.msg.error(err.message);
              if (npassphrase == null) return screen.render();
              screen._.prompt._.input.censor = true;
              return screen._.prompt.type('Verify Passphrase:', '', function(err, verify) {
                screen._.prompt._.input.censor = false;
                if (err) return screen._.msg.error(err.message);
                if (verify == null) return screen.render();
                if (npassphrase !== verify) {
                  return screen._.msg.error('Passphrases do not match.');
                }
                return changePassphrase(opassphrase, npassphrase, function(err) {
                  if (err) return screen._.msg.error(err.message);
                  return screen._.msg.display('Passphrase changed.');
                });
              });
            });
          });
        }
        screen._.prompt._.input.censor = true;
        return screen._.prompt.type('Passphrase:', '', function(err, passphrase) {
          screen._.prompt._.input.censor = false;
          if (err) return screen._.msg.error(err.message);
          if (passphrase == null) return screen.render();
          screen._.prompt._.input.censor = true;
          return screen._.prompt.type('Verify Passphrase:', '', function(err, verify) {
            screen._.prompt._.input.censor = false;
            if (err) return screen._.msg.error(err.message);
            if (verify == null) return screen.render();
            if (passphrase !== verify) {
              return screen._.msg.error('Passphrases do not match.');
            }
            screen.render();
            return encryptWallet(passphrase, function(err) {
              if (err) return screen._.msg.error(err.message);
              if (opt.remote) {
                return screen._.msg.display('Wallet is now encrypted.');
              }
              client.lock = true;
              screen._.loader.load('Restarting server...');
              return setTimeout(function() {
                return fs.unlink(platform.pid, function() {
                  return startServer(function() {
                    client.lock = false;
                    return decryptWallet(passphrase, 60 * 60, function() {
                      screen._.loader.stop();
                      decryptTime = Date.now();
                      return screen._.msg.display('Wallet is now encrypted.');
                    });
                  });
                });
              }, 10000);
            });
          });
        });
      });
    }

    if (text === 'Backup Wallet') {
      return backup();
    }

    if (text === 'Verify Message Signature') {
      return screen._.prompt.type('Address (Ctrl-E to select):', '', function(err, address) {
        if (err) return screen._.msg.error(err.message);
        if (address == null) return screen.render();
        return screen._.prompt.type('Signature:', '', function(err, sig) {
          if (err) return screen._.msg.error(err.message);
          if (sig == null) return screen.render();
          return screen._.prompt.type('Message:', '', function(err, message) {
            if (err) return screen._.msg.error(err.message);
            if (message == null) return screen.render();
            return verifyMessage(address, sig, message, function(err, result) {
              if (err) return screen._.msg.error(err.message);
              if (!result) {
                return screen._.msg.error('Not verified.');
              }
              return screen._.msg.display('Verified!');
            });
          });
        });
      });
    }

    if (text === 'Sign Message') {
      return checkEncrypt(function(err) {
        if (err) return screen._.msg.error(err.message);
        screen._.picker.setItems(Object.keys(stats.accounts));
        return screen._.picker.pick(function(err, address) {
          if (err) return screen._.msg.error(err.message);
          if (address == null) return screen.render();
          return screen._.prompt.type('Message:', '', function(err, message) {
            if (err) return screen._.msg.error(err.message);
            if (message == null) return screen.render();
            return signMessage(address, message, function(err, signature) {
              if (err) return screen._.msg.error(err.message);
              if (signature == null) return screen.render();
              return screen._.msg.display('Signature:\n' + signature, -1);
            });
          });
        });
      });
    }

    if (text === 'Rescan Block Chain') {
      screen._.loader.load('Rescanning (this may take a while)...');
      client.call('stop', [], function(err) {
        if (err) {
          client.lock = false;
          screen._.loader.stop();
          return screen._.msg.error(err.message);
        }
        return setTimeout(function() {
          return cp.execFile(platform.daemon, ['-rescan'], function(err, stdout, stderr) {
            if (err || stderr) {
              return startServer(function(err_) {
                client.lock = false;
                screen._.loader.stop();
                if (err_) {
                  screen.leave();
                  console.error('Fatal error: Could not restart server. Quitting.');
                  return proces.exit(1);
                }
                return screen._.msg.error(stderr || err.message);
              });
            }
            return startServer(function(err) {
              client.lock = false;
              screen._.loader.stop();
              if (err) {
                screen.leave();
                console.error('Fatal error: Could not restart server. Quitting.');
                return proces.exit(1);
              }
              return screen._.msg.display('Successfully rescanned addresses.');
            });
          });
        }, 12 * 1000);
      });
      client.lock = true;
      return;
    }

    if (text === 'Set Transaction Fee') {
      return screen._.prompt.type('Transaction Fee:', '0', function(err, value) {
        if (err) return screen._.msg.error(err.message);
        if (value == null) return screen.render();
        return client.call('settxfee', [+value], function(err) {
          if (err) return screen._.msg.error(err.message);
          return screen._.msg.display('Successfully set transaction fee.');
        });
      });
    }

    if (text === 'Import Private Key') {
      return checkEncrypt(function(err) {
        if (err) return screen._.msg.error(err.message);
        return screen._.prompt.type('Key:', '', function(err, key) {
          if (err) return screen._.msg.error(err.message);
          if (key == null) return screen.render();
          return screen._.prompt.type('Label:', '', function(err, label) {
            if (err) return screen._.msg.error(err.message);
            label = label || '';
            return screen._.question.ask('Rescan?', function(err, rescan) {
              if (err) return screen._.msg.error(err.message);
              if (rescan) {
                screen._.loader.load('Rescanning (this may take a while)...');
              }
              return client.call('importprivkey', [key, label, !!rescan], function(err) {
                if (rescan) screen._.loader.stop();
                if (err) return screen._.msg.error(err.message);
                return screen._.msg.display('Successfully set transaction fee.');
              });
            });
          });
        });
      });
    }

    if (text === 'Dump Private Key') {
      return checkEncrypt(function(err) {
        if (err) return screen._.msg.error(err.message);
        screen._.picker.setItems(Object.keys(stats.accounts));
        return screen._.picker.pick(function(err, address) {
          if (err) return screen._.msg.error(err.message);
          return client.call('dumpprivkey', [address], function(err, key) {
            if (err) return screen._.msg.error(err.message);
            return screen._.msg.display('Private Key: ' + key);
          });
        });
      });
    }

    if (text === 'Refill Key Pool') {
      return checkEncrypt(function(err) {
        if (err) return screen._.msg.error(err.message);
        screen._.loader.load('Refilling key pool...');
        return client.call('keypoolrefill', [], function(err, key) {
          screen._.loader.stop();
          if (err) return screen._.msg.error(err.message);
          return screen._.msg.display('Key pool refill complete.');
        });
      });
    }

    if (text === 'Toggle Coin Generation') {
      return client.call('getgenerate', [], function(err, generating) {
        if (err) return screen._.msg.error(err.message);
        if (generating) {
          return client.call('setgenerate', [false], function(err, key) {
            if (err) return screen._.msg.error(err.message);
            return screen._.msg.display('Stopped mining.');
          });
        }
        return screen._.prompt.type('Threads? (-1 for no. of cores)', '1', function(err, threads) {
          if (err) return screen._.msg.error(err.message);
          return client.call('setgenerate', [true, +threads], function(err, key) {
            if (err) return screen._.msg.error(err.message);
            return screen._.msg.display('Mining!');
          });
        });
      });
    }

    if (text === 'Get Mining Info') {
      return client.call('getmininginfo', [], function(err, info) {
        if (err) return screen._.msg.error(err.message);
        return screen._.msg.display(inspect(info), -1);
      });
    }
  });

  /**
   * Logs
   */

  tabs.logs.on('focus', function() {
    if (tabs.logs._.tail) return;
    tabs.logs._.tail = tailBox(platform.log, tabs.logs);
  });

  tabs.logs.on('blur', function() {
    if (tabs.logs._.tail) {
      tabs.logs._.tail();
      delete tabs.logs._.tail;
    }
  });

  /**
   * Debug
   */

  tabs.debug._.data = blessed.text({
    parent: tabs.debug,
    top: 0,
    left: 3,
    height: 'shrink',
    width: 'shrink',
    content: '',
    tags: true
  });

  tabs.debug.key(['f5', 'r'], function() {
    refresh();
  });

  /**
   * Global Widgets
   */

  screen._.prompt = blessed.prompt({
    parent: screen,
    top: 'center',
    left: 'center',
    height: 'shrink',
    width: 'shrink',
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    content: 'Label:',
    border: 'line',
    hidden: true
  });

  screen._.prompt._.input.key('C-e', function() {
    if (!screen.focused || screen.focused !== screen._.prompt._.input) {
      return;
    }
    screen._.prompt._.cancel.press();
    return pickAddress(function(err, value) {
      if (err) return screen.render();
      tabs.misc._.list.emit('select', tabs.misc._.list.items[1], 1);
      screen._.prompt._.input.setValue(value);
      screen.render();
    });
  });

  screen._.question = blessed.question({
    parent: screen,
    top: 'center',
    left: 'center',
    width: 'shrink',
    height: 'shrink',
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    content: 'Label:',
    border: 'line',
    hidden: true
  });

  screen._.fm = blessed.filemanager({
    parent: screen,
    top: 'center',
    left: 'center',
    width: '70%',
    height: '50%',
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    label: ' Choose a file... ',
    border: 'line',
    hidden: true
  });

  screen._.picker = blessed.list({
    parent: screen,
    top: 'center',
    left: 'center',
    width: '70%',
    height: '50%',
    border: 'line',
    keys: true,
    vi: true,
    mouse: true,
    tags: true,
    hidden: true,
    style: {
      scrollbar: {
        inverse: true
      },
      selected: {
        bg: 'blue'
      },
      item: {
        hover: {
          bg: 'blue'
        }
      }
    },
    scrollbar: {
      ch: ' '
    }
  });

  /**
   * Loader
   */

  screen._.loader = blessed.loading({
    parent: screen,
    top: 'center',
    left: 'center',
    height: 5,
    align: 'center',
    width: '50%',
    tags: true,
    hidden: true,
    border: 'line'
  });

  /**
   * Message
   */

  screen._.msg = blessed.message({
    parent: screen,
    top: 'center',
    left: 'center',
    // Fixed in blessed:
    // height: '50%',
    height: 'shrink',
    width: '50%',
    align: 'center',
    tags: true,
    hidden: true,
    border: 'line'
  });

  /**
   * QR Box
   */

  screen._.qrbox = blessed.box({
    parent: screen,
    scrollable: true,
    alwaysScroll: true,
    //top: 0,
    //left: 0,
    //bottom: 0,
    //right: 0,

    top: 1,
    bottom: 1,
    width: 80 + 6,
    //width: 'shrink',
    left: 'center',
    border: 'line',

    align: 'center',
    tags: true,
    hidden: true,
    keys: true,
    vi: true,
    scrollbar: {
      ch: ' '
    },
    style: {
      scrollbar: {
        inverse: true
      }
    }
  });

  screen._.qrbox._.show = function(content) {
    screen.saveFocus();
    screen._.qrbox.focus();
    screen._.qrbox.setContent(content);
    screen._.qrbox.show();
    screen.render();
  };

  screen._.qrbox.key(['q', 'escape'], function() {
    screen._.qrbox.hide();
    screen.restoreFocus();
    screen.render();
  });

  if (!stats.encrypted) {
    screen._.msg.display('Welcome to {blue-fg}termcoin{/blue-fg}!');
  }

  function checkEncrypt(callback) {
    if (!stats.encrypted) return callback();
    if (decryptTime && decryptTime + 60 * 60 * 1000 > Date.now()) return callback();
    screen._.prompt._.input.censor = true;
    return screen._.prompt.type('Enter your passphrase (valid for 60 min):', '', function(err, value) {
      screen._.prompt._.input.censor = false;
      if (err) {
        screen.render();
        return callback(err);
      }
      if (value == null) {
        return screen.render();
      }
      return forgetKey(function() {
        return decryptWallet(value, 60 * 60, function(err, result) {
          if (err) {
            screen.render();
            return callback(err);
          }
          decryptTime = Date.now();
          screen.render();
          return callback(null);
        });
      });
    });
  }

  function refresh(callback, noLoad) {
    if (client.lock) return callback();
    if (!noLoad) screen._.loader.load('Loading...');
    return getStats(function(err, stats_) {
      if (client.lock) return callback();
      if (err) {
        if (!noLoad) screen._.loader.stop();
        return;
      }

      stats = stats_;

      var items;

      // Wallet
      tabs.overview._.wallet.setContent(
        '{blue-fg}Balance{blue-fg}:     {yellow-fg}'
        + stats.balances.balance.toFixed(8) + '{/yellow-fg}\n'
        + '{red-fg}Unconfirmed{red-fg}: {yellow-fg}'
        + stats.balances.unconfirmed.toFixed(8) + '{/red-fg}');

      // Accounts
      var accounts = Object.keys(stats.accounts).map(function(key) {
        return stats.accounts[key];
      });
      accounts = asort(accounts);
      items = accounts.reduce(function(out, account) {
        var w = screen.width;
        var name = account.name || '[none]';
        var sp = Array(w - (account.address.length + name.length) - 3 + 1).join(' ');
        out.push('{blue-fg}' + name + '{/blue-fg}'
          + sp + '{green-fg}' + account.address + '{/green-fg}');
        return out;
      }, []);
      items.unshift('new');
      tabs.receive._.list.setItems(items);

      // Transactions
      items = stats.transactions.reduce(function(out, t) {
        var s;
        if (t.category === 'move') {
          // ID | Date | Type | Address | Amount
          s = '[move]'
            + ' | '
            + '{black-fg}' + new Date(t.time * 1000).toISOString() + '{/black-fg}'
            + ' | '
            + '{blue-fg}<->{/blue-fg}'
            + ' | '
            + '{green-fg}' + t.account + '{/green-fg}'
            + ' -> '
            + '{green-fg}' + t.otheraccount + '{/green-fg}'
            + ' | '
            + '{yellow-fg}' + t.amount + '{/yellow-fg}'
            + (t.comment ? ' - "' + t.comment + '"' : '');
        } else {
          // ID | Date | Type | Address | Amount-Fee | Confirmation
          s = t.txid.substring(0, 6)
            + ' | '
            + '{black-fg}' + new Date(t.time * 1000).toISOString() + '{/black-fg}'
            + ' | '
            //+ '{blue-fg}' + t.category + '{/blue-fg}'
            + (t.category === 'send'
              ? '{red-fg}->{/red-fg}'
              : '{green-fg}<-{/green-fg}')
            + ' | '
            + '{green-fg}' + t.address + '{/green-fg}'
            + ' | '
            + '{yellow-fg}' + t.amount + '{/yellow-fg}'
            + (t.fee ? '({red-fg}-' + t.fee + '{/red-fg})' : '')
            + ' | '
            + (t.confirmations < 3
              ? '{red-fg}Unconfirmed (' + t.confirmations + '){/red-fg}'
              : '{green-fg}Confirmed (' + t.confirmations + '){/green-fg}');
        }
        out.push(s);
        return out;
      }, []);
      tabs.transactions._.list.setItems(items);

      tabs.overview._.transactions.setContent(items.slice(0, 3).join('\n'));

      // Addresses
      var addresses = asort(stats.addresses);
      items = addresses.reduce(function(out, account) {
        var w = screen.width;
        var name = account.name || '[none]';
        var sp = Array(w - (account.address.length + name.length) - 3 + 1).join(' ');
        out.push('{blue-fg}' + name + '{/blue-fg}'
          + sp + '{green-fg}' + account.address + '{/green-fg}');
        return out;
      }, []);
      items.unshift('new');
      tabs.addresses._.list.setItems(items);

      // Debug
      tabs.debug._.data.setContent(inspect(stats));

      screen.render();

      if (!noLoad) screen._.loader.stop();

      return checkEncrypt(function(err) {
        if (err) screen._.msg.error(err.message);
        if (callback) callback();
      });
    });
  }

  screen.key('f5', function() {
    refresh();
  });

  (function self() {
    return refresh(function() {
      return setTimeout(self, 10 * 1000);
    }, true);
  })();

  screen.key(['C-c', 'q'], function(ch, key) {
    // TODO: Something like:
    //if (key.name === 'q') {
    //  if (screen.focused && (screen.focused.parent !== wrapper || screen.focused.parent._isTab)) {
    //    return;
    //  }
    //}
    if (!opt.host) {
      //client.call('stop', function() {
      return callback();
      return;
    }
    return callback();
  });

  screen.render();
}

function copy(text, callback) {
  var callback = callback || function() {};

  function exec(args) {
    var file = args.shift();
    var ps = cp.spawn(file, args, {
      stdio: ['pipe', 'ignore', 'ignore']
    });
    ps.stdin.on('error', callback);
    ps.on('error', callback);
    ps.on('exit', function(code) {
      return callback(code !== 0 ? new Error('Exit code: ' + code) : null);
    });
    ps.stdin.end(text + '');
  }

  if (opt.remote) return callback();

  // X11:
  return exec(['xsel', '-i', '-p'], function(err) {
    if (!err) return callback(null);
    return exec(['xclip', '-i', '-selection', 'primary'], function(err) {
      if (!err) return callback(null);
      // Mac:
      return exec(['pbcopy'], function(err) {
        if (!err) return callback(null);
        return callback(new Error('Failed to get clipboard contents.'));
      });
    });
  });
}

// `tail -f` a file.
function tailf(file) {
  //try {
  //  var stat = fs.statSync(file);
  //} catch (e) {
  //  var s = new (require('stream')).Stream;
  //  process.nextTick(function() { s.emit('error', e); });
  //  return s;
  //}
  //var options = { encoding: 'utf8', start: Math.max(0, stat.size - 2048) }

  var options = { encoding: 'utf8' }
    , stream = fs.createReadStream(file, options)
    , Stream = require('stream').Stream
    , s = new Stream
    , buff = '';

  var resume = function() {
    return setTimeout(function() {
      stream.resume();
    }, 1000);
  };

  var destroy = stream.destroy.bind(stream);

  s.readable = true;
  s.destroy = function() {
    destroy();
    s.emit('end');
    s.emit('close');
  };

  stream.destroy = function() {};

  stream.once('end', function() {
    stream.on('data', function(data) {
      s.emit('data', data);

      var data = (buff + data).split(/\n+/)
        , l = data.length - 1
        , i = 0;

      for (; i < l; i++) {
        s.emit('line', data[i]);
      }

      buff = data[l];
    });

    stream.on('error', function(err) {
      s.emit('error', err);
      s.destroy();
    });

    stream.on('end', function() {
      if (buff) {
        stream.emit('line', buff);
        buff = '';
      }

      resume();
    });

    resume();
  });

  return s;
};

function tailBox(file, box) {
  var stream = tailf(file)
    , rendering;

/*
  stream.on('line', function(line) {
    box.pushLine(line);
    if (box._clines.fake.length > 200) {
      //box.setContent('');
      box.shiftLine(100);
    }
    if (rendering) return;
    rendering = true;
    process.nextTick(function() {
      rendering = false;
      //box.setScroll(box.getScrollHeight());
      box.setScroll(box._clines.length);
      box.screen.render();
    });
  });
*/

  var lines = [];
  stream.on('line', function(line) {
    var h = box.height;
    if (lines.length >= h) {
      while (lines.length > h) {
        lines.shift();
      }
      box.setContent(lines.join('\n'));
      lines = [];
    }
    lines.push(line);
    if (rendering) return;
    rendering = true;
    process.nextTick(function() {
      rendering = false;
      //box.setScroll(box.getScrollHeight());
      box.setScroll(box._clines.length);
      box.screen.render();
    });
  });

  return stream.destroy.bind(stream);
}

function parseArg(argv) {
  var argv = argv.slice(2)
    , options = {}
    , files = [];

  function getarg() {
    var arg = argv.shift();

    if (arg.indexOf('--') === 0) {
      // e.g. --opt
      arg = arg.split('=');
      if (arg.length > 1) {
        // e.g. --opt=val
        argv.unshift(arg.slice(1).join('='));
      }
      arg = arg[0];
    } else if (arg[0] === '-') {
      if (arg.length > 2) {
        // e.g. -abc
        argv = arg.substring(1).split('').map(function(ch) {
          return '-' + ch;
        }).concat(argv);
        arg = argv.shift();
      } else {
        // e.g. -a
      }
    } else {
      // e.g. foo
    }

    return arg;
  }

  while (argv.length) {
    arg = getarg();
    switch (arg) {
      case '-c':
      case '--currency':
        options.currency = argv.shift();
        break;
      case '-s':
      case '--server':
        options.server = url.parse(argv.shift());
        if (options.server.auth) {
          var parts = options.server.auth.split(':');
          options.server.user = parts[0];
          options.server.password = parts[1] || '';
        }
        options.host = options.server.hostname;
        options.port = +options.server.port;
        options.user = options.server.user;
        options.password = options.server.password;
        options.ssl = options.server.protocol === 'https:';
        break;
      case '-h':
      case '--help':
        return help();
      case '--debug':
        options.debug = true;
        break;
      case '--mock':
        options.mock = true;
        break;
      default:
        if (~arg.indexOf('://')) {
          argv.unshift(arg);
          argv.unshift('-s');
        } else {
          files.push(arg);
        }
        break;
    }
  }

  if (!options.currency) {
    options.currency = 'bitcoin';
  }

  return options;
}

function help() {
  console.log('termcoin - a text ui for bitcoin/litecoin/dogecoin/etc.');
  return process.exit(0);
}

function main(callback) {
  if (opt.host
      && opt.host !== 'localhost'
      && opt.host !== '127.0.0.1'
      && opt.host !== '::1') {
    opt.remote = true;
  }

  config.rpcconnect = opt.host || config.rpcconnect || 'localhost';
  config.rpcport = opt.port || config.rpcport || 8332;
  config.rpcuser = opt.user || config.rpcuser || 'bitcoinrpc';
  config.rpcpassword = opt.password || config.rpcpassword || 'foobar';
  config.rpcssl = opt.ssl || config.rpcssl || false;

  client = new Client({
    host: config.rpcconnect,
    port: config.rpcport,
    user: config.rpcuser,
    pass: config.rpcpassword,
    ssl: config.rpcssl
  });

  return startServer(function(err) {
    if (err) return callback(err);
    return getStats(function(err, stats) {
      if (err) return callback(err);
      return start(stats, function(err) {
        if (err) return callback(err);
        return callback();
      });
    });
  });
}

/**
 * Client
 */

function Client(options) {
  this.options = options;
  this._id = 0;
}

Client.prototype.call = function(method, params, callback) {
  if (!callback) {
    callback = params;
    params = [];
  }
  return this._call({ method: method, params: params }, callback);
};

Client.prototype._call = function(call, options, callback) {
  var self = this;

  if (!callback) {
    callback = options;
    options = {};
  }

  if (Array.isArray(call)) {
    options.body = call.map(function(item) {
      return {
        id: self._id++,
        method: item.method,
        params: item.params
      };
    });
  } else {
    options.body = {
      id: self._id++,
      method: call.method,
      params: call.params
    };
  }

  return this.request(options, callback);
};

Client.prototype.request = function(options, callback) {
  var self = this
    , path = options.path || '/'
    , body = options.body || {}
    , method = options.method || 'POST'
    , cb = callback;

  if (typeof callback !== 'function') {
    callback = function() {};
  }

  options = {
    method: method,
    uri: (this.options.ssl ? 'https' : 'http')
      + '://'
      + this.options.user
      + ':'
      + this.options.pass
      + '@'
      + this.options.host
      + ':'
      + this.options.port
      + path,
    json: body
  };

  if (self.lock) return callback(null, {});
  return request(options, function(err, res, body) {
    if (self.lock) return callback(null, {});

    if (err) {
      return callback(new Error(err));
    }

    if (res.statusCode === 403 || res.statusCode === 401) {
      return callback(new Error('Forbidden.'));
    }

    if (res.statusCode === 404) {
      return callback(new Error('Not found.'));
    }

    try {
      if (typeof body === 'string') {
        body = JSON.parse(body);
      }
    } catch (e) {
      e.message += '\nStatus code: ' + res.statusCode + '.';
      e.message += '\nJSON: ' + body;
      return callback(e);
    }

    if (!body) {
      return callback(new Error('No body.'));
    }

    if (body.error) {
      err = new Error(body.error.message);
      err.code = body.error.code;
      return callback(err);
    }

    return callback(null, body.result);
  });
};

/**
 * Helpers
 */

function inspect(obj) {
  return typeof obj !== 'string'
    ? util.inspect(obj, false, 6, true)
    : obj;
}

function asort(obj) {
  return obj.sort(function(a, b) {
    a = a.name.toLowerCase().charCodeAt(0);
    b = b.name.toLowerCase().charCodeAt(0);
    return a - b;
  });
}

function tsort(obj, desc) {
  return obj.sort(function(a, b) {
    return desc
      ? b.time - a.time
      : a.time - b.time;
  });
}

function request(options, callback) {
  if (typeof options === 'string' || options.hostname) {
    options = { uri: options };
  }

  var uri = options.uri || options.url
    , body = options.json
        ? JSON.stringify(options.json)
        : options.body || '';

  if (typeof uri !== 'object') {
    uri = url.parse(uri);
  }

  if (options.qs) {
    var query = uri.query ? qs.parse(uri.query) : {};
    Object.keys(options.qs).forEach(function(key) {
      query[key] = options.qs[key];
    });
    uri.path = uri.pathname + '?' + qs.stringify(query);
  }

  var protocol = uri.prototype === 'https:'
    ? require('https')
    : http;

  options.method = options.method || (body ? 'POST' : 'GET');
  options.method = options.method.toUpperCase();
  options.headers = options.headers || {};

  if (options.json) {
    options.headers['Content-Type'] = 'application/json; charset=utf-8';
    options.headers['Accept'] = 'application/json';
  }

  if (options.method !== 'GET' && options.method !== 'HEAD') {
    options.headers['Content-Length'] = Buffer.byteLength(body);
  }

  var opt = {
    auth: uri.auth,
    host: uri.hostname,
    port: uri.port || (protocol === http ? 80 : 443),
    path: uri.path,
    method: options.method,
    headers: options.headers
  };

  var req = protocol.request(opt);

  req.on('response', function(res) {
    var decoder = new StringDecoder('utf8')
      , done = false
      , body = '';

    function end() {
      if (done) return;
      done = true;
      res.body = body;
      if (options.json) {
        try {
          body = JSON.parse(body);
        } catch (e) {
          ;
        }
      }
      callback(null, res, body);
      res.socket.removeListener('end', end);
    }

    res.on('data', function(data) {
      body += decoder.write(data);
    });

    res.on('error', function(err) {
      res.destroy();
      callback(err);
    });

    res.on('end', end);

    // An agent socket's `end` sometimes
    // wont be emitted on the response.
    res.socket.on('end', end);
  });

  req.end(body);
}

/**
 * Execute
 */

if (!module.parent) {
  process.title = 'termcoin';
  main(function(err) {
    if (err) throw err;
    return process.exit(0);
  });
} else {
  module.exports = main;
}
